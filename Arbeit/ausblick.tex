
\section{Zusammenfassung}

Die Aufgabenstellung für diese Arbeit war es, Methoden zu entwickeln mit denen man in der Lage ist zwei SQL-Anfragen miteinander zu vergleichen. Dabei sollte herausgefunden werden, ob die beiden Anfragen semantisch äquivalent sind und damit immer die gleichen Ergebnistupel produzieren. Entwickelte Methoden sollten dann in einem Programm realisiert werden, welches potentiell in der Lehre einsetzbar wäre. 

Zu diesem Zweck haben wir zunächst untersucht, was wir genau von unserem Programm erwarten. Wir haben festgestellt, dass semantisch-äquivalente Lösungen meist syntaktisch ähnlich sind. Daher haben wir uns überlegt, die SQL-Anfragen aneinander anzugleichen, indem wir legale Umformungen an beiden SQL-Anfragen durchführen. Motiviert von anderen Problemen in der Informatik, in denen eine Vorsortierung ein Problem oft vereinfachen kann, haben wir uns dazu entschlossen zunächst beide SQL-Anfragen nach festen Regeln zu standardisieren. Ziel dabei sollte sein, dass alle semantisch-äquivalenten SQL-Anfragen nach der Standardisierung auch syntaktisch gleich sind. Wenn zwei SQL-Anfragen nach der Standardisierung syntaktisch gleich sind, dann würden sie auch semantisch gleich sein. Dieser Schritt prüft also eine hinreichende Bedingung für semantische Äquivalenz.

Da es Anfragen gibt, die semantisch äquivalent sind, aber sich nicht aneinander angleichen lassen, haben wir einen zweiten Schritt entwickelt. Wir führen beide SQL-Anfragen auf Datenbanken mit echten Daten aus und vergleichen die Ergebnistupel. Sind diese nicht identisch, so verstößt dies gegen eine notwendige Bedingung: ``Auf allen Datenbankzuständen müssen zwei semantisch äquivalente SQL-Anfragen stets das gleiche Ergebnis liefern.'' 

Nach eingehender Analyse der bereits existierenden Lernplattformen zum Thema SQL, konnten wir feststellen, dass dieser Ansatz noch nicht realisiert worden ist. Wir haben Lernplattformen gesehen, die sich mit unserer Idee überschneiden, sie aber nie in dieser Form umsetzen. Nach dem Sichten von existierenden Lernplattformen haben wir den Fokus dieser Arbeit auf das Angleichen von SQL-Anfragen gelegt und verzichteten dafür, zum großen Teil, auf semantische Fehlermeldungen. 

Bevor wir mit der theoretischen Entwicklung unserer Methoden begonnen haben, untersuchten wir genau die zur Verfügung stehende Software. Dabei stand insbesondere der verwendete SQL-Parser 'ZQL' im Fokus der Betrachtungen. Nach einer eingehenden Analyse haben wir festgestellt, dass dieser einfach zu Verwenden und zu Erweitern ist, was ihn für unsere Zwecke attraktiv gemacht hat. Bei der Analyse haben wir auch festgestellt, dass der Parser Schwächen hat, die es vorerst verhindern einige unserer Konzepte in einem praktischen Programm umzusetzen.

In Kapitel \ref{chap:theorie} haben wir dann unsere Ideen aus der Vorbetrachtung in konkrete Methoden entwickelt. Wir haben uns überlegt, welche gleichen Konzepte in SQL in verschiedener Art und Weise formulierbar sind. Für Unterabfragen und Verbunde konnten wir so Methoden entwickeln, die die Vielfältigkeit der Formulierung dieser einschränken. Weiterhin haben wir syntaktische Variationen vereinheitlicht und uns mit der Frage beschäftigt wie man der Operatorenvielfalt in einer SQL-Anfrage begegnen kann. Schlussendlich entwickelten wir eine Sortiermethode, die es uns erlaubt eine feste Ordnung in einem Operatorbaum, der den \verb|WHERE|-Ausdruck einer SQL-Anfrage darstellt, zu etablieren. Aufgrund der Beschränktheit durch den Parser war es uns nicht möglich alle entwickelten Methoden und Betrachtungen in unsere Anwendung umzusetzen. Weiterhin haben wir untersucht was für Probleme auftreten, wenn wir SQL-Anfragen auf externen Datenbanken ausführen, um die notwendige Bedingung der Äquivalenz zu prüfen.

Nachdem die entwickelten Methoden mit Java und JSP implementiert wurden, haben wir die Programmstruktur im Kapitel \ref{chap:praxis} eingehend erläutert. Die Anwendung wurde im Wesentlichen in drei Hauptprozesse aufgeteilt, die mit Hilfe der JSP gesteuert und dem Nutzer per Web-UI zur Verfügung gestellt werden. 

Es wurde erfolgreich eine Anwendung entworfen, die theoretische Betrachtungen und, in dieser Arbeit, entwickelte Methoden umsetzt. Dabei werden, wie gefordert, zwei SQL-Anfragen miteinander verglichen. Im konkreten Fall handelt es sich dabei um eine Musterlösung und eine Lösung eines Lernenden. Es wird geprüft, ob die beiden semantisch Äquivalent sind. Die Anwendung kann als Grundstein für eine Lernplattform dienen, in der es leicht ist neue Aufgaben einzupflegen und der Lernende ein umfassenderes Feedback erhält, als es vom normalen SQL-Parser eines DBMS möglich ist.

\section{Ausblick}

Einige der entwickelten Methoden aus Kapitel \ref{chap:theorie} konnte nicht umgesetzt werden. Die Ursachen dafür liegen hauptsächlich bei den Schwächen des verwendeten Parsers. Dies sollte für zukünftige Arbeiten aber nur minimale Probleme mit sich bringen, da der Parser quelloffen ist und unter der GNU GPLv3 steht. Damit ist er leicht anpassbar und kann auch offiziell wiederverwendet werden. Die nicht implementierten Methoden sind dennoch ausführlich behandelt, sodass ein nachträgliches Implementieren einfach möglich ist. Eine große Schwäche des Parsers ist es, dass die \verb|FROM|-Klausel nur als Liste von Relationen geparst wird. Dadurch verhindert es der Parser Verbunde und Unterabfragen in \verb|FROM| zu formulieren. Während Unterabfragen unter \verb|FROM| recht selten sind, sind aber Verbunde innerhalb der \verb|FROM|-Klausel durchaus üblich. Würde der Parser um diese Funktionen erweitert werden, so ist es leicht möglich eine Vielzahl unserer Verbundsüberlegungen aus Abschnitt \ref{subsec:joins} zu übernehmen.

Weiterhin gibt es noch Probleme bei der Standardisierung, die wir nicht ausführlich betrachtet haben. So ist weiterhin offen, wie genau man mit komplexeren arithmetischen Ausdrücken in einer Anfrage umgeht. Wir haben zwar einige Ideen aufgezeigt, diese sind aber nicht umfangreich genug, um sie in einem Algorithmus zu manifestieren. Weiterhin haben wir uns von Anfang an auf \verb|SELECT|-Anfragen beschränkt. Um alle SQL-Anfragen abzudecken muss noch untersucht werden, wie mit den übrigen Arten von SQL-Anfragen umgegangen werden muss, damit diese vergleichbar sind. 

Nützlich für unsere Anwendung wäre es außerdem, wenn wir Methoden von anderen Lernplattformen übernehmen und in unsere integrieren. Denkbar wäre es die Aufgaben mit einer Schwierigkeitsstufe zu versehen, damit man ein 'Matchmaking'-System so etablieren kann, dass der Student weder gelangweilt noch überfordert ist. Weiterhin ist denkbar viel mehr semantic-checks einzubauen, wie \mbox{z. B.} eine ausführliche Analyse des Wertebereichs von Attributen. Damit könnte man viele inkonsistente Anfragen bereits vor der Standardisierung erkennen. Dies würde dem Lernenden, unabhängig von der Musterlösung, mehr Feedback zu seiner SQL-Anfrage geben. 

Unter Umständen haben wir den Fall, dass wir die Äquivalenz zweier Anfragen weder bestätigen, noch ablehnen können. Um die Leistung unserer Anwendung zu steigern gilt es, die Häufigkeit solcher Fälle zu verringern. Sind also Verbesserungen implementiert worden, so macht es Sinn Testreihen mit Studenten durchzuführen und zu messen, ob die Häufigkeit dieser ungünstigen Fälle zurückgegangen ist.

