%einleitung

SQL (structured query language) ist eine Datenbanksprache, die in relationalen Datenbanken zum Definieren, Ändern und Abfragen von Datenbeständen benutzt wird. Basierend auf relationaler Algebra und dem Tupelkalkül, ist sie einfach aufgebaut und ähnelt der englischen Sprache sehr, was Anfragen deutlich verständlicher gestaltet. SQL ist der Standard in der Industrie wenn es um Datenbankmanagementsysteme (DBMS) geht. Zu bekannten Vertretern gehören Oracle Database von der Oracle Corporation, DB2 von IBM, PostgreSQL von der PostgreSQL Global Development Group, MySQL von der Oracle Corporation und SQLServer von Microsoft.

Die Umsetzung von SQL als quasi-natürliche Sprache erlaubt es Anfragen so zu formulieren, dass sie allein mit dem Verständnis der natürlichen Sprache zu verstehen sind. Dieser Umstand hat auch dazu geführt, dass heutzutage relationale Datenbanksysteme mit SQL beliebt sind und häufig eingesetzt werden. 
Dies führt allerdings auch dazu, dass es mehrere, syntaktisch unterschiedliche, Anfragen geben kann, welche semantisch identisch sind. Einige Anfragen sehen sich dabei ähnlich, andere kann man nur nach komplizierterem Umformen ineinander überführen. 

\section{Motivation}

Ein gängiges Mittel, um herauszufinden ob zwei SQL-Anfragen das gleiche Ergebnis liefern, ist es die Anfragen auf einer Datenbank mit vorhandenen Daten auszuführen. Das Ergebnis dieses Vorganges bildet jedoch lediglich Indizien für eine mögliche semantische Gleichheit. Da man die zwei zu vergleichenden Anfragen nur auf einer endlichen Menge von Datenbankzuständen testen kann, ist nie ausgeschlossen, dass nicht doch ein Zustand existiert, der unterschiedliche Ergebnisse liefert. Weiterhin stehen solche Testdaten nur im begrenzten Umfang zur Verfügung oder Daten müssten händisch eingetragen werden bzw. von freien Internetdatenbanken beschafft werden. Dies kostet Zeit und Arbeitskraft, welche im universitären Umfeld meist beschränkt sind. So haben Hochschulen immer weniger Geld für Tutoren oder Hilfskräfte, was die Zeit der wenigen Mitarbeiter umso wertvoller macht.

Durch diese Situation sind Professoren immer öfter dazu gezwungen mehr Lehre und weniger Forschung zu betreiben, was aber offensichtlich keine gute Lösung ist. Häufig werden dem Lernenden Übungsaufgaben gestellt, die dieser dann innerhalb einer Frist bearbeitet und abgibt. Diese müssen dann kontrolliert und wieder ausgehändigt werden. Bei diesem Prozess kann nur schwer auf die einzelnen Fehler der Studenten eingegangen werden. Auch ist es ein zusätzlicher Zeitaufwand herauszufinden, welche Fehler besonders häufig auftreten. Des weiteren sind manche Lernende auch gewillt mehr zu üben, um sich gerüstet für eine Klausur zu fühlen. Andere möchten gezielt ein Thema üben, welches sie noch nicht gut beherrschen. All das ist mit Übungsaufgaben und Übungen innerhalb der Hochschule schwer zu erreichen. 

Das Programm, welches im Rahmen dieser Arbeit entwickelt wird, soll helfen all diese Probleme zu lösen. Es soll mit wenig Aufwand für den Mitarbeiter der Universität möglich sein neue Aufgaben in das System einzupflegen. Durch Abspeicherung sämtlicher Lösungsversuche des Lernenden, können einzelne Aufgaben vom Dozenten durch das Programm auf häufig auftretende Fehler untersucht werden. Damit kann in der Übung gezielt besprochen werden, was noch oft falsch gemacht wird.

\section{Aufgabenstellung}

Nach der theoretischen Ausarbeitung soll ein Programm entwickelt werden, welches in der Lage ist zwei SQL-Anfragen zu vergleichen. Dieser Vergleich soll, im ersten Schritt, lediglich mit Musterlösung, Lösung des Lernenden und Datenbankschema möglich sein. Im zweiten Schritt werden die zwei Anfragen auch gegen reale Daten geprüft. Da die Fehlermeldungen der Parser von bekannten DBMS sehr allgemein gehalten sind, ist es auch wünschenswert, dass das Programm konkretere Hinweis- und Fehlermeldung ausgibt. Weiterhin sollen die Fehlermeldungen sich konkret auf den Unterschied zwischen Musterlösung und der Lösung des Lernenden beziehen. Damit das Programm möglichst plattformunabhängig bedient werden kann, soll es als Webseite auf einem Server zur Verfügung gestellt werden. Da als Programmiersprache Java gewählt wurde, bieten sich die JSP (java server pages) an, welche auf den java-servlets basieren.

Wir bezeichnen zwei SQL-Anfragen als syntaktisch gleich, wenn die zwei Anfragen syntaktisch identisch sind. Dies ist der Fall wenn beide Anfragen als Zeichenketten in jedem Buchstaben übereinstimmen. Zwei SQL-Anfragen sind dagegen semantisch äquivalent, wenn beide Anfragen auf allen Datenbankzuständen einer Datenbank stets die selben Tupel zurückliefern. Zu bemerken ist hierbei, dass zwei semantisch äquivalente Anfragen keinesfalls syntaktisch gleich sein müssen, wie das folgende Beispiel zeigt:

\begin{figure}[h]
\begin{verbatim}
Anfrage 1: SELECT * FROM emp WHERE sal > 1000
Anfrage 2: SELECT * FROM emp e WHERE 1000 < e.sal
\end{verbatim}
\caption{Beispiel: semantisch, aber nicht syntaktisch, äquivalente Anfragen}
\end{figure}

Wie bereits beschrieben erfolgt der Vergleich zweier SQL-Anfragen zweistufig. Können beide Anfragen durch Standardisierungen in syntaktisch gleiche Anfragen umgeformt werden, so sind sie auf jeden Fall auch semantisch äquivalent. Das Umformen durch Standardisierung stellt daher eine hinreichende Bedingung für die semantische Äquivalenz der SQL-Anfragen dar. Können wir durch die Standardisierung keine syntaktisch gleichen Anfragen erzeugen, so fahren wir mit dem zweiten Schritt fort. In diesem werden beide Anfragen auf realen Datenbanken ausgeführt. Sind beide Anfragen semantisch äquivalent, so müssen beide die selben Ergebnistupel liefern. Ist dies nicht der Fall, so ist ein Gegenbeispiel für die semantische Äquivalenz gefunden. Das Liefern von gleichen Ergebnissen beider Anfragen auf dem selben Datenbankzustand ist also eine notwendige Bedingung für die semantische Äquivalenz. Im Kapitel \ref{chap:ausblick} wird noch auf Anfragen eingegangen, die weder im Schritt 1 bestätigt noch im Schritt 2 abgelehnt werden konnten. 


Ein Haupteinsatzgebiet dieses Ansatzes ist die Lehre. Dort soll es möglich sein Untersuchungen des Lernfortschritts von Studenten oder anderen Interessierten, die den Einsatz von SQL erlernen möchten, durchzuführen. So kann das Programm dem Lernenden nicht nur sinnvolle Hinweise bei einer falschen Lösung geben, sondern auch erläutern, ob die gefundene Lösung eventuell zu kompliziert gedacht war. Des Weiteren ist es aufgrund der zentralisierten Serverstruktur möglich, Lösungsversuche des Lernenden zu speichern und eine persönliche Lernerfolgskurve anzeigen zu lassen. Damit hätten Studenten und Lehrkräfte die Möglichkeiten Lernfortschritte zu beobachten und Problemfelder (etwa JOINs) zu erkennen um diese dann gezielt zu bearbeiten. Dozenten könnten so im Zuge der Vorbereitung der Übung oder Vorlesung sich die am häufigsten aufgetretenen Fehler anzeigen lassen, um diese dann mit den Studenten direkt zu besprechen.

Damit ist es möglich eine Lernplattform aufzubauen, die dem Studenten mehrere Auswertungsinformationen über seinen Lernerfolg und seine Lösung zur Verfügung stellt. So kann die Lehrkraft eine Aufgabe mit samt Musterlösung und Datenbankschema hinterlegen und der Student kann daraufhin seine Lösungsversuche in das System eintragen. Durch sinnvolles Feedback ist es dem Lernenden möglich, beim Üben leichter und effizienter zu lernen. Weiterhin kann man eine solche Plattform auch für Tutorien oder Nachhilfe benutzen, sowie überall dort, wo SQL gelernt wird. Vorteile hier wären, dass man mehrere verschiedene Aufgaben stellen kann ohne viel Zeit beim Einpflegen von neuen Aufgaben verbringen zu müssen.

\section{Aufbau der Arbeit}

Im vorherigen Abschnitt haben wir geklärt warum es eine Notwendigkeit für das Thema SQL-Vergleich gibt. Zu dem wurde geklärt, was das Ziel der Arbeit ist. 

Im Kapitel \ref{chap:forschung} betrachten wir den aktuellen Forschungsstand zur Thematik Lernplattformen und SQL. Das Ergebnis dieser Arbeit soll ein Produkt sein, was hauptsächlich in der Lehre eingesetzt wird. Daher ist es wichtig bereits vorhandene Lernplattformen zu untersuchen. Dabei interessieren uns insbesondere Gemeinsamkeiten und Unterschiede zu unserer Arbeit. Wir werden feststellen, dass jede Plattform auf einen bestimmten Aspekt spezialisiert ist und andere Aspekte dann eine untergeordnete Rolle spielen. Weiterhin ist diese Bestandsaufnahme wichtig, da sie uns aufzeigen kann, wie man mögliche Ansätze miteinander verknüpft. Dieser Gedanke wird im Kapitel \ref{chap:ausblick} genauer erläutert.

Im nachfolgenden Kapitel \ref{chap:software} beschreiben wir die verwendete Software. Zunächst wird der verwendete Parser ausführlich erläutert. Dabei gehen wir nicht nur auf seine genaue Funktionsweise, sondern auch auf seine Schwächen ein. Diese ziehen gewisse Einschränkungen mit sich, mit denen wir uns in nachfolgenden Teilen der Arbeit befassen werden. Des weiteren wird die Funktionsweise von Java Server Pages (JSP) kurz umrissen. Am Ende des Kapitels \ref{chap:software} listen wir die verwendete Software auf, um nachzuvollziehen wie unsere Anwendung entstanden ist.

Die Fragestellung ``Sind zwei SQL-Anfragen äquivalent?'' ist nicht entscheidbar. Aus diesem Grund klären wir im Kapitel \ref{chap:theorie} wie wir den Entscheidungsprozess angehen wollen, sodass zumindest eine Teilmenge von SQL-Anfragen bearbeitet werden kann. Es wird zunächst eine Methode entwickelt, die zwei SQL-Anfragen auf semantische Äquivalenz prüfen soll. Danach werden die einzelnen Schritte dieser Methode ausführlich diskutiert. Dabei behandeln wir auch alternative Ansätze und Einschränkungen, die durch verwendete Software oder durch einen erhöhten Komplexitätsgrad entstehen. Ansätze, die wir Aufgrund erhöhter Komplexität nicht in der Anwendung unterbringen können, werden dennoch ausführlich erläutert, so dass eine spätere Implementierung leicht umzusetzen ist.

In Kapitel \ref{chap:praxis} wird der konkrete Aufbau unserer Anwendung erläutert. Dabei klären wir die verwendete Datenbankstruktur, sowie den Programmablauf für die wichtigsten Hauptprozesse. Dieses Kapitel dient, vor allem, zum Verständnis der Umsetzung der in Kapitel \ref{chap:theorie} erläuterten Methoden.
%TODO: Ergebnisse und Ausblick (zusammenfassen)

\section{Produkt}

Im Rahmen der Aufgabenstellung wird ein Programm entwickelt, das es erlaubt zwei SQL-\\Anfragen auf semantische Äquivalenz zu vergleichen. Dazu wird eine Lernplattform auf Basis von Java Server Pages geschaffen. Der Lernende meldet sich über ein Webformular bei der Plattform an. Auf der Startseite werden ihm seine letzten Aktionen auf der Plattform angezeigt. Weiterhin findet er eine Statistik über bereits behandelte Aufgaben. Der Lernende kann sich aus einer Liste von verschiedenen Aufgaben eine auswählen. Er erhält dann das konkrete Datenbankschema sowie eine Textaufgabe, die ihm die Aufgabenstellung vermittelt. Nach Einreichen einer Lösung wird ausgewertet, ob diese mit der Musterlösung gematcht werden und eine semantische Äquivalenz sicher ausgeschlossen werden konnte. Das Ergebnis dieser Auswertung wird dem Lernenden, zusammen mit Hinweisen zu seiner Lösung, ausgegeben.

Der Dozent hat die Möglichkeit einfach und schnell weitere Aufgaben in das System einzupflegen. Dazu muss er eine Aufgabenstellung in Textform sowie mindestens eine SQL-Anfrage als Musterlösung hinterlegen. Damit die Anfrage des Lernenden und die Musterlösung im zweiten Schritt unserer Anwendung auch gegen echte Daten geprüft werden können, bedarf es noch der Angabe von mindestens einer externen Datenbank. Diese externen Datenbanken können durch ein Webformular eingetragen werden.

